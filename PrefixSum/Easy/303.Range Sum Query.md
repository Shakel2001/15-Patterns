303\. Range Sum Query -- Immutable (LeetCode)
============================================

**Problem link (for reference):**\
<https://leetcode.com/problems/range-sum-query-immutable/description/>

We need to design a class `NumArray` that:

-   Initializes with an integer array `nums`.

-   Answers queries to compute the sum of elements from index `left` to `right` (inclusive).

* * * * *

Problem Statement (from LeetCode)
---------------------------------

> Given an integer array `nums`, handle multiple queries of the following type:\
> Calculate the sum of the elements of `nums` between indices `left` and `right` inclusive where `left <= right`.
>
> Implement the `NumArray` class:
>
> -   `NumArray(int[] nums)`: Initializes the object with the integer array `nums`.
>
>
> -   `int sumRange(int left, int right)`: Returns the sum of the elements of `nums` between indices `left` and `right` inclusive.

Example:
```
Input
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output : [null, 1, -1, -3]
```

Explanation
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // returns 1
numArray.sumRange(2, 5); // returns --1
numArray.sumRange(0, 5); // returns --3`

* * * * *

Solution Approaches
-------------------

### 1\. Brute-Force

**Idea:** For each query, iterate from `left` to `right` and accumulate the sum.

**Code:**
```cpp
class NumArray {
public:
    vector<int> arr;

    NumArray(vector<int>& nums) {
        arr = nums;
    }

    int sumRange(int left, int right) {
        int sum = 0;
        for (int i = left; i <= right; i++) {
            sum += arr[i];
        }
        return sum;
    }
};
```

**Complexity:**

-   **Time (per query):** O(n) in worst case (if querying the full array).

-   **Space:** O(1) --- no extra memory used.

**Downside:** Could be too slow for up to 10⁴ queries.

* * * * *

### 2\. Optimized: Prefix-Sum Method

**Idea:** Build a prefix sum array `prefixSum`, where:

`prefixSum[i] = sum of nums[0..i-1],  for i ≥ 1
prefixSum[0] = 0`

To answer a query:

`sumRange(left, right) = prefixSum[right + 1] - prefixSum[left]`

**Code:**
```cpp
class NumArray {
public:
    vector<int> prefixSum;

    NumArray(vector<int>& nums) {
        int n = nums.size();
        prefixSum.resize(n + 1);
        prefixSum[0] = 0;
        for (int i = 1; i <= n; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }
    }

    int sumRange(int left, int right) {
        return prefixSum[right + 1] - prefixSum[left];
    }
};
```

**Complexity:**

-   **Preprocessing Time:** O(n)

-   **Query Time:** O(1)

-   **Space:** O(n) --- for the `prefixSum` array.

* * * * *

Comparison Summary
------------------

| Approach | Preprocessing | Query Time | Space |
| --- | --- | --- | --- |
| Brute-Force | O(1) | O(n) | O(1) |
| Prefix-Sum | O(n) | O(1) | O(n) |

* * * * *

Brute Force vs Prefix Sum: When to Use Which?
---------------------------------------------

-   **Brute-Force:** Acceptable if only a few queries are made.

-   **Prefix-Sum:** Ideal when there are many queries (as in this problem) -- it scales efficiently.

* * * * *

Bonus: Dry-Run Example of Prefix-Sum
------------------------------------

Consider `nums = [-2, 0, 3, -5, 2, -1]`

1.  Build `prefixSum`:

    `prefixSum = [0,
                 -2,      // sum of [-2]
                 -2 + 0 = -2,
                 -2 + 3 = 1,
                 1 + (-5) = -4,
                 -4 + 2 = -2,
                 -2 + (-1) = -3]
    prefixSum = [0, -2, -2, 1, -4, -2, -3]`

2.  Queries:

    -   `sumRange(0, 2)` → `prefixSum[3] - prefixSum[0] = 1 - 0 = 1`

    -   `sumRange(2, 5)` → `prefixSum[6] - prefixSum[2] = -3 - (-2) = -1`

    -   `sumRange(0, 5)` → `prefixSum[6] - prefixSum[0] = -3 - 0 = -3`
