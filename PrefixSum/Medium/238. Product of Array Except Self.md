# üìù Problem: 238. Product of Array Except Self  

**LeetCode Link:** [238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)

=============================================================================================

You are given an integer array `nums`. Return an array `answer` such that `answer[i] = product of all elements in nums except nums[i]`.

-   Must run in **O(n)** time.

-   **No division allowed**.

-   Products fit in 32-bit integer.

* * * * *

Example
-------

**Input:** `nums = [1,2,3,4]`\
**Output:** `[24,12,8,6]`

**Input:** `nums = [-1,1,0,-3,3]`\
**Output:** `[0,0,9,0,0]`

* * * * *

üîπ Approach 1: Brute Force
--------------------------

### Logic

-   For each index `i`, compute the product of all elements except `nums[i]`.

-   Just multiply all others using nested loops.

### Code (Brute Force)
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n);
        for(int i=0; i<n; i++){
            long long product = 1;
            for(int j=0; j<n; j++){
                if(i != j){
                    product *= nums[j];
                }
            }
            ans[i] = product;
        }
        return ans;
    }
};
```

### Complexity

-   ‚è± **Time:** O(n¬≤) ‚Üí two loops

-   üíæ **Space:** O(1) (ignoring output array)

* * * * *

üîπ Approach 2: Prefix & Suffix Arrays
-------------------------------------

### Logic

-   `prefix[i] = product of all elements before i`.

-   `suffix[i] = product of all elements after i`.

-   Final `ans[i] = prefix[i] * suffix[i]`.

### Code
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();

        vector<int> prefix(n), suffix(n), ans(n);
        prefix[0] = 1;
        for(int i=1; i<n; i++){
            prefix[i] = prefix[i-1] * nums[i-1];
        }

        suffix[n-1] = 1;
        for(int i=n-2; i>=0; i--){
            suffix[i] = suffix[i+1] * nums[i+1];
        }

        for(int i=0; i<n; i++){
            ans[i] = prefix[i] * suffix[i];
        }
        return ans;
    }
};
```

### Complexity

-   ‚è± **Time:** O(n)

-   üíæ **Space:** O(n) (prefix + suffix arrays)

* * * * *

üîπ Approach 3: Optimized O(1) Space
-----------------------------------

### Logic

-   Store result in `ans` directly using prefix (left product).

-   Multiply with suffix (right product) in reverse pass.

-   Saves space ‚Üí no need for extra prefix/suffix arrays.

### Code
```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, 1);

        int left = 1;
        for(int i=0; i<n; i++){   // left product
            ans[i] *= left;
            left *= nums[i];
        }

        int right = 1;
        for(int i=n-1; i>=0; i--){  // right product
            ans[i] *= right;
            right *= nums[i];
        }

        return ans;
    }
};
```

### Complexity

-   ‚è± **Time:** O(n)

-   üíæ **Space:** O(1) (only output array used) ‚úÖ **Best Solution**

* * * * *

‚úÖ Final Comparison
------------------

| Approach | Time | Space |
| --- | --- | --- |
| Brute Force | O(n¬≤) | O(1) |
| Prefix + Suffix | O(n) | O(n) |
| Optimized (Two pass) | O(n) | O(1) |

* * * * *

üëâ Best to use **Approach 3** in interviews (efficient & clean).
