[ğŸ“ Problem: 523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/description/)
========================================

[Video Link](https://www.youtube.com/watch?v=tW4BBWF8VJk)

* * * * *

ğŸ“Œ Problem Statement
--------------------

Given an integer array `nums` and an integer `k`, return **true** if there exists a subarray of length **at least 2** whose sum is a **multiple of k**.

* * * * *

ğŸ” Example
----------

**Input:** `nums = [23, 2, 4, 6, 7], k = 6`\
**Subarray:** `[2,4]` â†’ sum = 6 â†’ multiple of 6\
**Output:** `true`

* * * * *

ğŸš© Constraints
--------------

-   `1 <= nums.length <= 1e5`

-   `0 <= nums[i] <= 1e9`

-   `0 <= sum(nums[i]) <= 2^31 - 1`

-   `1 <= k <= 2^31 - 1`

* * * * *

ğŸ›  Brute Force Approach
-----------------------

### ğŸ”¹ Logic

-   Generate all possible subarrays of length â‰¥ 2.

-   Compute sum of each subarray.

-   If sum is divisible by `k`, return `true`.

-   If no subarray works, return `false`.

* * * * *

### ğŸ”¹ Algorithm

1.  Loop over all starting indices `i`.

2.  Initialize `sum = 0`.

3.  For every ending index `j` from `i` to `n-1`:

    -   Add `nums[j]` to `sum`.

    -   If `(j - i + 1 >= 2 && sum % k == 0)`, return `true`.

4.  Return `false`.

* * * * *

### ğŸ”¹ Code (Brute Force)
```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            long long sum = 0;
            for(int j = i; j < n; j++) {
                sum += nums[j];
                if(j - i + 1 >= 2 && sum % k == 0) {
                    return true;
                }
            }
        }
        return false;
    }
};
```
* * * * *

### ğŸ”¹ Complexity

-   **Time:** `O(n^2)` (too slow for `n=1e5`).

-   **Space:** `O(1)`

* * * * *

âš¡ Optimized Approach (Prefix Sum + Modulo HashMap)
--------------------------------------------------

### ğŸ”¹ Key Observation

-   Subarray sum `(i, j)` = `prefix[j] - prefix[i-1]`.

-   If `(prefix[j] - prefix[i-1]) % k == 0` â†’ `prefix[j] % k == prefix[i-1] % k`.

-   So:

    -   Keep track of prefix sums modulo `k`.

    -   If we see the same remainder again, the subarray between them has sum multiple of `k`.

    -   Ensure subarray length â‰¥ 2.

* * * * *

### ğŸ”¹ Algorithm

1.  Initialize `unordered_map<int,int> mp` â†’ store remainder â†’ first index.

    -   Start with `mp[0] = -1` (handles subarray starting at index 0).

2.  Iterate through `nums`:

    -   Update `prefixSum`.

    -   Compute `rem = prefixSum % k` (adjust if negative).

    -   If `rem` already in `mp` and `(i - mp[rem]) >= 2` â†’ return `true`.

    -   Else store `mp[rem] = i`.

3.  If no valid subarray found â†’ return `false`.

* * * * *

### ğŸ”¹ Code (Optimized)
```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int,int> mp;
        int prefixSum = 0;
        mp[0] = -1; // base case

        for(int i = 0; i < n; i++) {
            prefixSum += nums[i];
            int rem = prefixSum % k;
            if(rem < 0) rem += k; // handle negative

            if(mp.find(rem) != mp.end()) {
                if(i - mp[rem] >= 2) return true;
            } else {
                mp[rem] = i; // store first occurrence
            }
        }
        return false;
    }
};
```

* * * * *

### ğŸ”¹ Complexity

-   **Time:** `O(n)`

-   **Space:** `O(min(n, k))` (hashmap of remainders)

* * * * *

âœ… Example Dry Run
-----------------

**nums = [23,2,6,4,7], k = 6**

-   Start: `mp={0:-1}, prefix=0`

-   i=0 â†’ prefix=23 â†’ rem=5 â†’ mp={0:-1,5:0}

-   i=1 â†’ prefix=25 â†’ rem=1 â†’ mp={0:-1,5:0,1:1}

-   i=2 â†’ prefix=31 â†’ rem=1 â†’ found in map at idx=1 â†’ i-1=1 â†’ subarray length=1 (not valid)

-   i=3 â†’ prefix=35 â†’ rem=5 â†’ found in map at idx=0 â†’ i-0=3 â‰¥ 2 â†’ âœ… return true

**Answer = true**

* * * * *

ğŸ“Œ **Summary:**

-   Brute Force â†’ `O(n^2)` â†’ checks all subarrays.

-   Optimized â†’ `O(n)` using **prefix sum % k + hashmap**.
