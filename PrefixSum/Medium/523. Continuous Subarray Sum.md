[📝 Problem: 523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/description/)
========================================

[Video Link](https://www.youtube.com/watch?v=tW4BBWF8VJk)

* * * * *

📌 Problem Statement
--------------------

Given an integer array `nums` and an integer `k`, return **true** if there exists a subarray of length **at least 2** whose sum is a **multiple of k**.

* * * * *

🔍 Example
----------

**Input:** `nums = [23, 2, 4, 6, 7], k = 6`\
**Subarray:** `[2,4]` → sum = 6 → multiple of 6\
**Output:** `true`

* * * * *

🚩 Constraints
--------------

-   `1 <= nums.length <= 1e5`

-   `0 <= nums[i] <= 1e9`

-   `0 <= sum(nums[i]) <= 2^31 - 1`

-   `1 <= k <= 2^31 - 1`

* * * * *

🛠 Brute Force Approach
-----------------------

### 🔹 Logic

-   Generate all possible subarrays of length ≥ 2.

-   Compute sum of each subarray.

-   If sum is divisible by `k`, return `true`.

-   If no subarray works, return `false`.

* * * * *

### 🔹 Algorithm

1.  Loop over all starting indices `i`.

2.  Initialize `sum = 0`.

3.  For every ending index `j` from `i` to `n-1`:

    -   Add `nums[j]` to `sum`.

    -   If `(j - i + 1 >= 2 && sum % k == 0)`, return `true`.

4.  Return `false`.

* * * * *

### 🔹 Code (Brute Force)
```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        for(int i = 0; i < n; i++) {
            long long sum = 0;
            for(int j = i; j < n; j++) {
                sum += nums[j];
                if(j - i + 1 >= 2 && sum % k == 0) {
                    return true;
                }
            }
        }
        return false;
    }
};
```
* * * * *

### 🔹 Complexity

-   **Time:** `O(n^2)` (too slow for `n=1e5`).

-   **Space:** `O(1)`

* * * * *

⚡ Optimized Approach (Prefix Sum + Modulo HashMap)
--------------------------------------------------

### 🔹 Key Observation

-   Subarray sum `(i, j)` = `prefix[j] - prefix[i-1]`.

-   If `(prefix[j] - prefix[i-1]) % k == 0` → `prefix[j] % k == prefix[i-1] % k`.

-   So:

    -   Keep track of prefix sums modulo `k`.

    -   If we see the same remainder again, the subarray between them has sum multiple of `k`.

    -   Ensure subarray length ≥ 2.

* * * * *

### 🔹 Algorithm

1.  Initialize `unordered_map<int,int> mp` → store remainder → first index.

    -   Start with `mp[0] = -1` (handles subarray starting at index 0).

2.  Iterate through `nums`:

    -   Update `prefixSum`.

    -   Compute `rem = prefixSum % k` (adjust if negative).

    -   If `rem` already in `mp` and `(i - mp[rem]) >= 2` → return `true`.

    -   Else store `mp[rem] = i`.

3.  If no valid subarray found → return `false`.

* * * * *

### 🔹 Code (Optimized)
```cpp
class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int,int> mp;
        int prefixSum = 0;
        mp[0] = -1; // base case

        for(int i = 0; i < n; i++) {
            prefixSum += nums[i];
            int rem = prefixSum % k;
            if(rem < 0) rem += k; // handle negative

            if(mp.find(rem) != mp.end()) {
                if(i - mp[rem] >= 2) return true;
            } else {
                mp[rem] = i; // store first occurrence
            }
        }
        return false;
    }
};
```

* * * * *

### 🔹 Complexity

-   **Time:** `O(n)`

-   **Space:** `O(min(n, k))` (hashmap of remainders)

* * * * *

✅ Example Dry Run
-----------------

**nums = [23,2,6,4,7], k = 6**

-   Start: `mp={0:-1}, prefix=0`

-   i=0 → prefix=23 → rem=5 → mp={0:-1,5:0}

-   i=1 → prefix=25 → rem=1 → mp={0:-1,5:0,1:1}

-   i=2 → prefix=31 → rem=1 → found in map at idx=1 → i-1=1 → subarray length=1 (not valid)

-   i=3 → prefix=35 → rem=5 → found in map at idx=0 → i-0=3 ≥ 2 → ✅ return true

**Answer = true**

* * * * *

📌 **Summary:**

-   Brute Force → `O(n^2)` → checks all subarrays.

-   Optimized → `O(n)` using **prefix sum % k + hashmap**.
