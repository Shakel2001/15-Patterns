ğŸ“ Problem: 974. Subarray Sums Divisible by K
=============================================

[LeetCode Link](https://leetcode.com/problems/subarray-sums-divisible-by-k/)\
[YouTube Explanation](https://www.youtube.com/watch?v=a_k29lPEEjk)

* * * * *

ğŸ“Œ Problem Statement
--------------------

You are given an integer array `nums` and an integer `k`.\
Return the **number of non-empty subarrays** whose **sum is divisible by k**.

-   A subarray is a contiguous part of an array.

* * * * *

### Example 1:

**Input:**\
`nums = [4,5,0,-2,-3,1], k = 5`\
**Output:** `7`

**Explanation:**\
Subarrays divisible by `5` are:

-   `[4, 5, 0, -2, -3, 1]`

-   `[5]`

-   `[5, 0]`

-   `[5, 0, -2, -3]`

-   `[0]`

-   `[0, -2, -3]`

-   `[-2, -3]`

* * * * *

### Example 2:

**Input:**\
`nums = [5], k = 9`\
**Output:** `0`

* * * * *

âœ… Brute Force Approach
----------------------

### Idea

-   Generate **all possible subarrays**.

-   Compute the sum of each subarray.

-   Check if the sum is divisible by `k`.

### Code (C++)
```cpp
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size();
        int count = 0;

        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum % k == 0) {
                    count++;
                }
            }
        }
        return count;
    }
};
```

### Complexity

-   **Time:** O(nÂ²) â†’ two loops for subarrays

-   **Space:** O(1)

* * * * *

ğŸš€ Optimal Approach (Prefix Sum + HashMap)
------------------------------------------

### Idea

-   Use **prefix sum** and **modulo property**:

    -   If two prefix sums have the **same remainder modulo `k`**, the subarray between them has sum divisible by `k`.

-   Store counts of remainders in a hashmap.

### Code (C++)
```cpp
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int, int> mp;
        mp[0] = 1;  // base case

        int prefixSum = 0, count = 0;

        for (int i = 0; i < n; i++) {
            prefixSum += nums[i];

            int mod = prefixSum % k;
            if (mod < 0) mod += k; // handle negative remainders

            if (mp.find(mod) != mp.end()) {
                count += mp[mod];
            }
            mp[mod]++;
        }
        return count;
    }
};
```

* * * * *

ğŸ” Complexity Analysis
----------------------

-   **Time:** O(n) â†’ single pass through array

-   **Space:** O(k) â†’ storing remainders in hashmap

* * * * *

âœ… Summary
---------

-   Brute force works but is **too slow for n = 3*10â´**.

-   Optimal solution with **prefix sum + hashmap** runs in **O(n)** and is required for constraints.
