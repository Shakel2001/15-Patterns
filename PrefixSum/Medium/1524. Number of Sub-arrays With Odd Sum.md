📝 Problem: 1524. Number of Sub-arrays With Odd Sum
===================================================

[LeetCode Link](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/description/)

* * * * *

📌 Problem Statement
--------------------

You are given an integer array `arr`. You need to count the number of subarrays whose sum is **odd**.\
Since the result can be large, return the answer **modulo 1e9+7**.

* * * * *

🔍 Example
----------

**Input:** `arr = [1,3,5]`\
**All subarrays:** `[1], [1,3], [1,3,5], [3], [3,5], [5]`\
**Their sums:** `[1, 4, 9, 3, 8, 5]`\
Odd sums → `[1, 9, 3, 5]` → **4 subarrays**

**Output:** `4`

* * * * *

🚩 Constraints
--------------

-   `1 <= arr.length <= 10^5`

-   `1 <= arr[i] <= 100`

* * * * *

🛠 Brute Force Approach
-----------------------

### 🔹 Logic

-   Iterate over all possible subarrays `(i, j)`.

-   For each subarray, calculate sum and check if it is odd.

-   Count it if odd.

### 🔹 Algorithm

1.  Initialize `count = 0`.

2.  For every starting index `i` from `0` to `n-1`:

    -   Initialize `sum = 0`.

    -   For every ending index `j` from `i` to `n-1`:

        -   Add `arr[j]` to `sum`.

        -   If `sum % 2 == 1`, increment `count`.

3.  Return `count`.

### 🔹 Code (Brute Force)
```cpp
class Solution {
public:
    int numOfSubarrays(vector<int>& arr) {
        int n = arr.size();
        int count = 0;
        for(int i=0; i<n; i++){
            int sum = 0;
            for(int j=i; j<n; j++){
                sum += arr[j];
                if(sum % 2 == 1) count++;
            }
        }
        return count;
    }
};
```

### 🔹 Complexity

-   **Time:** `O(n^2)` → too slow for `n = 1e5`.

-   **Space:** `O(1)`

* * * * *

⚡ Optimized Approach (Prefix Sum + Parity Counting)
---------------------------------------------------

### 🔹 Key Observation

-   A subarray `(i, j)` is **odd** if:\
    `prefixSum[j] - prefixSum[i-1]` is odd.

-   Which means:

    -   `prefixSum[j]` and `prefixSum[i-1]` must have **different parity**.

So, instead of computing every subarray sum, we just track how many **prefix sums are odd/even**.

* * * * *

### 🔹 Logic

1.  Maintain two counters:

    -   `even` = number of prefix sums that are even (initially `1` because sum = 0 is even).

    -   `odd` = number of prefix sums that are odd.

2.  Iterate through array, update running prefix sum:

    -   If prefix sum is even → it pairs with **odd prefix sums**.

    -   If prefix sum is odd → it pairs with **even prefix sums**.

3.  Add valid counts to result.

* * * * *

### 🔹 Algorithm

1.  Initialize `res = 0, odd = 0, even = 1`.

2.  Loop through elements:

    -   Add `arr[i]` to `prefixSum`.

    -   If `prefixSum` is even:

        -   Add `odd` to result (because odd + even = odd).

        -   Increment `even`.

    -   Else (odd prefix sum):

        -   Add `even` to result.

        -   Increment `odd`.

3.  Return `res % MOD`.

* * * * *

### 🔹 Code (Optimized)
```cpp
class Solution {
public:
    int numOfSubarrays(vector<int>& arr) {
        long long MOD = 1e9+7;
        long long odd = 0, even = 1;
        long long prefixSum = 0, res = 0;

        for(int num : arr) {
            prefixSum += num;
            if(prefixSum % 2 == 0) {
                res = (res + odd) % MOD;
                even++;
            } else {
                res = (res + even) % MOD;
                odd++;
            }
        }
        return res;
    }
};
```
* * * * *

### 🔹 Complexity

-   **Time:** `O(n)` (single pass).

-   **Space:** `O(1)` (only counters).

* * * * *

✅ Example Dry Run
-----------------

**arr = [1,2,3]**

-   Start: even = 1, odd = 0, res = 0

-   i=0 → prefixSum=1 (odd) → res += even=1 → res=1, odd=1

-   i=1 → prefixSum=3 (odd) → res += even=1 → res=2, odd=2

-   i=2 → prefixSum=6 (even) → res += odd=2 → res=4, even=2

**Answer = 4**

* * * * *

📌 **Summary:**

-   Brute Force → `O(n^2)` (not feasible for `n=1e5`).

-   Optimized (Prefix sum + Parity count) → `O(n)` and `O(1)` space.
