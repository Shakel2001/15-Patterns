[📝 Problem: 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)
======================================

📌 Problem Statement
--------------------

Given an array `nums` and an integer `k`, return the **total number of subarrays** whose sum equals `k`.

* * * * *

🔍 Example
----------

**Input:** `nums = [1,1,1], k = 2`\
**Subarrays:**

-   `[1,1] (sum=2)`

-   `[1,1] (sum=2)`\
    **Output:** `2`

* * * * *

🚩 Constraints
--------------

-   `1 <= nums.length <= 2 * 10^4`

-   `-1000 <= nums[i] <= 1000`

-   `-10^7 <= k <= 10^7`

* * * * *

🛠 Brute Force Approach
-----------------------

### 🔹 Logic

-   Generate all subarrays `(i, j)`.

-   Compute sum of each subarray.

-   If sum = `k`, increase count.

### 🔹 Algorithm

1.  Initialize `count = 0`.

2.  For each starting index `i`:

    -   Initialize `sum = 0`.

    -   For each ending index `j`:

        -   Add `nums[j]` to `sum`.

        -   If `sum == k`, increment `count`.

3.  Return `count`.

* * * * *

### 🔹 Code (Brute Force)
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int count = 0;

        for(int i=0; i<n; i++) {
            int sum = 0;
            for(int j=i; j<n; j++) {
                sum += nums[j];
                if(sum == k) count++;
            }
        }
        return count;
    }
};
```

* * * * *

### 🔹 Complexity

-   **Time:** `O(n^2)` (nested loop).

-   **Space:** `O(1)`

⚠️ Works only for small `n` (up to ~2000).

* * * * *

⚡ Optimized Approach (Prefix Sum + HashMap)
-------------------------------------------

### 🔹 Key Observation

-   Let `prefixSum[i] = nums[0] + ... + nums[i]`.

-   Subarray `(i, j)` sum = `prefixSum[j] - prefixSum[i-1]`.

-   For a valid subarray:\
    `prefixSum[j] - prefixSum[i-1] = k` →\
    `prefixSum[i-1] = prefixSum[j] - k`.

So, we just need to check how many times `(prefixSum[j] - k)` has appeared before.

* * * * *

### 🔹 Algorithm

1.  Initialize a hashmap `mp` with `mp[0] = 1` (handles case when subarray starts at index 0).

2.  Maintain `prefixSum = 0` and `count = 0`.

3.  Loop through array:

    -   Add current `nums[i]` to `prefixSum`.

    -   Compute `remove = prefixSum - k`.

    -   If `remove` exists in map, add `mp[remove]` to `count`.

    -   Store `prefixSum` in `mp` (increment frequency).

4.  Return `count`.

* * * * *

### 🔹 Code (Optimized)
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        mp[0] = 1; // base case: empty subarray
        int prefixSum = 0, count = 0;

        for(int num : nums) {
            prefixSum += num;
            int remove = prefixSum - k;

            if(mp.find(remove) != mp.end()) {
                count += mp[remove];
            }
            mp[prefixSum]++;
        }

        return count;
    }
};
```

* * * * *

### 🔹 Complexity

-   **Time:** `O(n)`

-   **Space:** `O(n)` (hashmap for prefix sums).

* * * * *

✅ Example Dry Run
-----------------

**nums = [1,2,3], k = 3**

-   Start: `mp={0:1}, prefixSum=0, count=0`

-   i=0 → prefixSum=1 → remove=-2 (not in map) → mp={0:1,1:1}

-   i=1 → prefixSum=3 → remove=0 → found mp[0]=1 → count=1 → mp={0:1,1:1,3:1}

-   i=2 → prefixSum=6 → remove=3 → found mp[3]=1 → count=2 → mp={0:1,1:1,3:1,6:1}

**Answer = 2** ✅

* * * * *

📌 **Summary:**

-   Brute Force → `O(n^2)` (check all subarrays).

-   Optimized → `O(n)` using **prefix sum + hashmap**.
