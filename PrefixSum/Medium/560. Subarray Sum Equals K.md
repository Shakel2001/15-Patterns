[ğŸ“ Problem: 560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/description/)
======================================

ğŸ“Œ Problem Statement
--------------------

Given an array `nums` and an integer `k`, return the **total number of subarrays** whose sum equals `k`.

* * * * *

ğŸ” Example
----------

**Input:** `nums = [1,1,1], k = 2`\
**Subarrays:**

-   `[1,1] (sum=2)`

-   `[1,1] (sum=2)`\
    **Output:** `2`

* * * * *

ğŸš© Constraints
--------------

-   `1 <= nums.length <= 2 * 10^4`

-   `-1000 <= nums[i] <= 1000`

-   `-10^7 <= k <= 10^7`

* * * * *

ğŸ›  Brute Force Approach
-----------------------

### ğŸ”¹ Logic

-   Generate all subarrays `(i, j)`.

-   Compute sum of each subarray.

-   If sum = `k`, increase count.

### ğŸ”¹ Algorithm

1.  Initialize `count = 0`.

2.  For each starting index `i`:

    -   Initialize `sum = 0`.

    -   For each ending index `j`:

        -   Add `nums[j]` to `sum`.

        -   If `sum == k`, increment `count`.

3.  Return `count`.

* * * * *

### ğŸ”¹ Code (Brute Force)
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        int count = 0;

        for(int i=0; i<n; i++) {
            int sum = 0;
            for(int j=i; j<n; j++) {
                sum += nums[j];
                if(sum == k) count++;
            }
        }
        return count;
    }
};
```

* * * * *

### ğŸ”¹ Complexity

-   **Time:** `O(n^2)` (nested loop).

-   **Space:** `O(1)`

âš ï¸ Works only for small `n` (up to ~2000).

* * * * *

âš¡ Optimized Approach (Prefix Sum + HashMap)
-------------------------------------------

### ğŸ”¹ Key Observation

-   Let `prefixSum[i] = nums[0] + ... + nums[i]`.

-   Subarray `(i, j)` sum = `prefixSum[j] - prefixSum[i-1]`.

-   For a valid subarray:\
    `prefixSum[j] - prefixSum[i-1] = k` â†’\
    `prefixSum[i-1] = prefixSum[j] - k`.

So, we just need to check how many times `(prefixSum[j] - k)` has appeared before.

* * * * *

### ğŸ”¹ Algorithm

1.  Initialize a hashmap `mp` with `mp[0] = 1` (handles case when subarray starts at index 0).

2.  Maintain `prefixSum = 0` and `count = 0`.

3.  Loop through array:

    -   Add current `nums[i]` to `prefixSum`.

    -   Compute `remove = prefixSum - k`.

    -   If `remove` exists in map, add `mp[remove]` to `count`.

    -   Store `prefixSum` in `mp` (increment frequency).

4.  Return `count`.

* * * * *

### ğŸ”¹ Code (Optimized)
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> mp;
        mp[0] = 1; // base case: empty subarray
        int prefixSum = 0, count = 0;

        for(int num : nums) {
            prefixSum += num;
            int remove = prefixSum - k;

            if(mp.find(remove) != mp.end()) {
                count += mp[remove];
            }
            mp[prefixSum]++;
        }

        return count;
    }
};
```

* * * * *

### ğŸ”¹ Complexity

-   **Time:** `O(n)`

-   **Space:** `O(n)` (hashmap for prefix sums).

* * * * *

âœ… Example Dry Run
-----------------

**nums = [1,2,3], k = 3**

-   Start: `mp={0:1}, prefixSum=0, count=0`

-   i=0 â†’ prefixSum=1 â†’ remove=-2 (not in map) â†’ mp={0:1,1:1}

-   i=1 â†’ prefixSum=3 â†’ remove=0 â†’ found mp[0]=1 â†’ count=1 â†’ mp={0:1,1:1,3:1}

-   i=2 â†’ prefixSum=6 â†’ remove=3 â†’ found mp[3]=1 â†’ count=2 â†’ mp={0:1,1:1,3:1,6:1}

**Answer = 2** âœ…

* * * * *

ğŸ“Œ **Summary:**

-   Brute Force â†’ `O(n^2)` (check all subarrays).

-   Optimized â†’ `O(n)` using **prefix sum + hashmap**.
