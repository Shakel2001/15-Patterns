📘 2270. Number of Ways to Split Array
======================================

**LeetCode Link:**\
https://leetcode.com/problems/number-of-ways-to-split-array/

* * * * *

🔹 Problem Statement
--------------------

We are given an integer array `nums` of length `n`.

A split at index `i` is **valid** if:

1.  `sum(nums[0..i]) >= sum(nums[i+1..n-1])`

2.  `0 <= i < n-1` (i.e., there must be at least one element on the right).

We need to **count the number of valid splits**.

* * * * *

🔹 Example 1
------------
```
Input: nums = [10,4,-8,7]
Output: 2

Explanation:
Split at i = 0 → left = 10, right = 3 → valid
Split at i = 1 → left = 14, right = -1 → valid
Split at i = 2 → left = 6, right = 7 → not valid
Answer = 2
```

* * * * *

🔹 Example 2
------------
```
Input: nums = [2,3,1,0]
Output: 2

Explanation:
Split at i = 1 → left = 5, right = 1 → valid
Split at i = 2 → left = 6, right = 0 → valid
Answer = 2
```

* * * * *

🔹 Brute Force Approach
-----------------------

👉 For every split index `i`, compute left sum and right sum separately.

### Code:
```cpp
class Solution {
public:
    int waysToSplitArray(vector<int>& nums) {
        int n = nums.size();
        int count = 0;

        for (int i = 0; i < n - 1; i++) {
            long long leftSum = 0, rightSum = 0;

            for (int j = 0; j <= i; j++) leftSum += nums[j];
            for (int j = i + 1; j < n; j++) rightSum += nums[j];

            if (leftSum >= rightSum) count++;
        }
        return count;
    }
};
```

### Complexity:

-   **Time:** O(n²) (nested loops).

-   **Space:** O(1).\
    ⚠️ Will **TLE** for `n = 10⁵`.

* * * * *

🔹 Optimized Approach 1 (Prefix Sum)
------------------------------------

👉 Use **prefix sum array** to avoid recomputation.

-   Compute total sum.

-   For each index `i`,

    -   `left = prefix[i]`

    -   `right = total - prefix[i]`

### Code:
```cpp
class Solution {
public:
    int waysToSplitArray(vector<int>& nums) {
        int n = nums.size();
        vector<long long> prefix(n);
        prefix[0] = nums[0];

        for (int i = 1; i < n; i++) {
            prefix[i] = prefix[i - 1] + nums[i];
        }

        int count = 0;
        for (int i = 0; i < n - 1; i++) {
            long long leftSum = prefix[i];
            long long rightSum = prefix[n - 1] - prefix[i];

            if (leftSum >= rightSum) count++;
        }
        return count;
    }
};
```

### Complexity:

-   **Time:** O(n) (single pass after prefix).

-   **Space:** O(n).

* * * * *

🔹 Optimized Approach 2 (Running Sum -- No Extra Array)
------------------------------------------------------

👉 Instead of storing prefix sums, maintain a running `left` sum and update `right` by subtracting.

### Code:
```cpp
class Solution {
public:
    int waysToSplitArray(vector<int>& nums) {
        long long total = 0;
        for (int x : nums) total += x;

        long long left = 0;
        int count = 0;

        for (int i = 0; i < nums.size() - 1; i++) {
            left += nums[i];
            total -= nums[i]; // now total = right sum

            if (left >= total) count++;
        }
        return count;
    }
};
```

### Complexity:

-   **Time:** O(n).

-   **Space:** O(1). ✅ Best solution.

* * * * *

🔹 Comparison Table
-------------------

| Approach | Time | Space | Notes |
| --- | --- | --- | --- |
| Brute Force | O(n²) | O(1) | Too slow for n=10⁵ |
| Prefix Sum Array | O(n) | O(n) | Efficient |
| Running Sum ✅ | O(n) | O(1) | Best solution |
