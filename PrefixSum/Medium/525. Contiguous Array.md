[ğŸ“ Problem: 525.Contiguous Array](https://leetcode.com/problems/contiguous-array/description/)
=================================

ğŸ“Œ Problem Statement
--------------------

Given a binary array `nums`, return the **maximum length** of a contiguous subarray with an **equal number of 0 and 1**.

* * * * *

ğŸ” Example
----------

**Input:** `nums = [0,1,0]`\
**Subarrays:**

-   `[0,1]` â†’ length 2 âœ…

-   `[1,0]` â†’ length 2 âœ…

-   `[0,1,0]` â†’ unequal (2 zeros, 1 one)\
    **Output:** `2`

* * * * *

ğŸš© Constraints
--------------

-   `1 <= nums.length <= 1e5`

-   `nums[i]` is either `0` or `1`.

* * * * *

ğŸ›  Brute Force Approach
-----------------------

### ğŸ”¹ Logic

-   Generate all possible subarrays `(i, j)`.

-   Count zeros and ones in each subarray.

-   If they are equal â†’ update max length.

### ğŸ”¹ Algorithm

1.  Initialize `maxLen = 0`.

2.  For each starting index `i`:

    -   Initialize `zeroCount = 0, oneCount = 0`.

    -   For each ending index `j` from `i` to `n-1`:

        -   If `nums[j] == 0`, increment `zeroCount`.

        -   Else increment `oneCount`.

        -   If `zeroCount == oneCount`, update `maxLen = max(maxLen, j-i+1)`.

3.  Return `maxLen`.

### ğŸ”¹ Code (Brute Force)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size();
        int maxLen = 0;

        for(int i=0; i<n; i++) {
            int zeroCount = 0, oneCount = 0;
            for(int j=i; j<n; j++) {
                if(nums[j] == 0) zeroCount++;
                else oneCount++;
                if(zeroCount == oneCount) {
                    maxLen = max(maxLen, j-i+1);
                }
            }
        }
        return maxLen;
    }
};
```

### ğŸ”¹ Complexity

-   **Time:** `O(n^2)`

-   **Space:** `O(1)`\
    âš ï¸ Too slow for `n=1e5`.

* * * * *

âš¡ Optimized Approach (Prefix Sum + HashMap)
-------------------------------------------

### ğŸ”¹ Key Observation

-   Replace `0 â†’ -1`, `1 â†’ +1`.

-   Now the problem reduces to finding the **longest subarray with sum = 0**.

-   Use prefix sum + hashmap to store **first index of each prefix sum**.

* * * * *

### ğŸ”¹ Algorithm

1.  Replace all `0` with `-1`.

2.  Maintain `prefixSum = 0` and `unordered_map<int,int> mp` (store first index of prefixSum).

    -   Initialize `mp[0] = -1` (handles subarray starting from index 0).

3.  Iterate through array:

    -   Add `nums[i]` to `prefixSum`.

    -   If `prefixSum` is already in map:

        -   `maxLen = max(maxLen, i - mp[prefixSum])`.

    -   Else, store `mp[prefixSum] = i`.

4.  Return `maxLen`.

* * * * *

### ğŸ”¹ Code (Optimized)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        for(int &i : nums) {
            if(i == 0) i = -1; // convert 0 to -1
        }

        int prefixSum = 0;
        int maxLen = 0;
        unordered_map<int,int> mp;
        mp[0] = -1;  // base case

        for(int i=0; i<nums.size(); i++) {
            prefixSum += nums[i];
            if(mp.find(prefixSum) != mp.end()) {
                maxLen = max(maxLen, i - mp[prefixSum]);
            } else {
                mp[prefixSum] = i;
            }
        }
        return maxLen;
    }
};
```

* * * * *

### ğŸ”¹ Complexity

-   **Time:** `O(n)` (single pass).

-   **Space:** `O(n)` (hashmap for prefix sums).

* * * * *

âœ… Example Dry Run
-----------------

**nums = [0,1,1,0]**\
Convert â†’ `[-1,1,1,-1]`

-   Start: prefixSum=0, mp={0:-1}, maxLen=0

-   i=0 â†’ sum=-1 â†’ store mp[-1]=0

-   i=1 â†’ sum=0 â†’ found in map â†’ maxLen=max(0,1-(-1))=2

-   i=2 â†’ sum=1 â†’ store mp[1]=2

-   i=3 â†’ sum=0 â†’ found â†’ maxLen=max(2,3-(-1))=4

**Answer = 4**

* * * * *

ğŸ“Œ **Summary:**

-   Brute Force â†’ `O(n^2)`, works for small inputs.

-   Optimized â†’ `O(n)` using **prefix sum + hashmap**, suitable for `n=1e5`.
