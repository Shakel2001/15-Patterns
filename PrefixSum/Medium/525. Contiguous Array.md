[📝 Problem: 525.Contiguous Array](https://leetcode.com/problems/contiguous-array/description/)
=================================

📌 Problem Statement
--------------------

Given a binary array `nums`, return the **maximum length** of a contiguous subarray with an **equal number of 0 and 1**.

* * * * *

🔍 Example
----------

**Input:** `nums = [0,1,0]`\
**Subarrays:**

-   `[0,1]` → length 2 ✅

-   `[1,0]` → length 2 ✅

-   `[0,1,0]` → unequal (2 zeros, 1 one)\
    **Output:** `2`

* * * * *

🚩 Constraints
--------------

-   `1 <= nums.length <= 1e5`

-   `nums[i]` is either `0` or `1`.

* * * * *

🛠 Brute Force Approach
-----------------------

### 🔹 Logic

-   Generate all possible subarrays `(i, j)`.

-   Count zeros and ones in each subarray.

-   If they are equal → update max length.

### 🔹 Algorithm

1.  Initialize `maxLen = 0`.

2.  For each starting index `i`:

    -   Initialize `zeroCount = 0, oneCount = 0`.

    -   For each ending index `j` from `i` to `n-1`:

        -   If `nums[j] == 0`, increment `zeroCount`.

        -   Else increment `oneCount`.

        -   If `zeroCount == oneCount`, update `maxLen = max(maxLen, j-i+1)`.

3.  Return `maxLen`.

### 🔹 Code (Brute Force)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        int n = nums.size();
        int maxLen = 0;

        for(int i=0; i<n; i++) {
            int zeroCount = 0, oneCount = 0;
            for(int j=i; j<n; j++) {
                if(nums[j] == 0) zeroCount++;
                else oneCount++;
                if(zeroCount == oneCount) {
                    maxLen = max(maxLen, j-i+1);
                }
            }
        }
        return maxLen;
    }
};
```

### 🔹 Complexity

-   **Time:** `O(n^2)`

-   **Space:** `O(1)`\
    ⚠️ Too slow for `n=1e5`.

* * * * *

⚡ Optimized Approach (Prefix Sum + HashMap)
-------------------------------------------

### 🔹 Key Observation

-   Replace `0 → -1`, `1 → +1`.

-   Now the problem reduces to finding the **longest subarray with sum = 0**.

-   Use prefix sum + hashmap to store **first index of each prefix sum**.

* * * * *

### 🔹 Algorithm

1.  Replace all `0` with `-1`.

2.  Maintain `prefixSum = 0` and `unordered_map<int,int> mp` (store first index of prefixSum).

    -   Initialize `mp[0] = -1` (handles subarray starting from index 0).

3.  Iterate through array:

    -   Add `nums[i]` to `prefixSum`.

    -   If `prefixSum` is already in map:

        -   `maxLen = max(maxLen, i - mp[prefixSum])`.

    -   Else, store `mp[prefixSum] = i`.

4.  Return `maxLen`.

* * * * *

### 🔹 Code (Optimized)
```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        for(int &i : nums) {
            if(i == 0) i = -1; // convert 0 to -1
        }

        int prefixSum = 0;
        int maxLen = 0;
        unordered_map<int,int> mp;
        mp[0] = -1;  // base case

        for(int i=0; i<nums.size(); i++) {
            prefixSum += nums[i];
            if(mp.find(prefixSum) != mp.end()) {
                maxLen = max(maxLen, i - mp[prefixSum]);
            } else {
                mp[prefixSum] = i;
            }
        }
        return maxLen;
    }
};
```

* * * * *

### 🔹 Complexity

-   **Time:** `O(n)` (single pass).

-   **Space:** `O(n)` (hashmap for prefix sums).

* * * * *

✅ Example Dry Run
-----------------

**nums = [0,1,1,0]**\
Convert → `[-1,1,1,-1]`

-   Start: prefixSum=0, mp={0:-1}, maxLen=0

-   i=0 → sum=-1 → store mp[-1]=0

-   i=1 → sum=0 → found in map → maxLen=max(0,1-(-1))=2

-   i=2 → sum=1 → store mp[1]=2

-   i=3 → sum=0 → found → maxLen=max(2,3-(-1))=4

**Answer = 4**

* * * * *

📌 **Summary:**

-   Brute Force → `O(n^2)`, works for small inputs.

-   Optimized → `O(n)` using **prefix sum + hashmap**, suitable for `n=1e5`.
